\chapter{Fundamentação teórica}

\section{Desenvolvimento de software} % (fold)
\label{sec:desenvolvimento_de_software}

% section desenvolvimento_de_software (end)

\subsection{Métodos tradicionais} % (fold)
\label{sub:metodos_tradicionais}

A base para diversos métodos de desenvolvimento que vêm sendo utilizado há décadas na indústria do software $-$ por isso métodos tradicionais $-$ é o modelo em cascata. Ele sugere uma abordagem sistemática e sequencial para o desenvolvimento de software que começa com a especificação dos requisitos pelo cliente e progire ao longo do planejamento, modelagem, construção, e implantação, culminando na manutenção progressiva do software acabado \cite{Pressman}.

\citeonline{XPTeles} e \citeonline{BDDRodrigo} fazem um apanhado sobre a relação entre o modelo cascata com os processos de produção industriais tayloristas. Estes processos tem como premissas o determinismo e a especialização. Dessa forma, isso leva ao desenvolvimento em cascata a especializar o desenvolvimento, ou seja, separar papéis na equipe de desenvolvimento onde cada um tem uma única responsabilidade. Além disso, existe uma busca pelo determinismo, que ganha força ao ser amparado pelo famosa curva de custos de correção do software por tempo transcorrido desde o início do processo \cite{Boehm}, mostrada na Figura \ref{img:custo-cascata}.

\begin{figure}[h]
  \center
  \caption{O custo das modificações no modelo tradicional - Fonte: \cite{XPKent}}
  \includegraphics[scale=0.35]{images/custo-cascata}
  \label{img:custo-cascata}
\end{figure}

Esta busca pelo determinismo fez com que se pensasse, de forma completamente equivocada, que ao tentar com bastante afinco, consegue-se antecipar todo o conjunto de requisitos e reduzir os custos eliminando as mudanças \cite{TheBusinessOfInnovation}.

Ainda se baseando no processo de produção industrial, desta vez no gerenciamento fordista, outra premissa extremamente equivocada englobada pelo modelo cascada é a de que desenvolvimento de software é um trabalho executado por trabalhadores manuais e não um trabalhadores do conhecimento \cite[38]{XPTeles}.

Embora o desenvolvimento em cascata seja reconhecidamente ineficaz, ainda é o processo mais utilizado para o desenvolvimento de sistemas \cite{XPTeles}.

% subsection metodos_tradicionais (end)


\subsection{Agilismo} % (fold)
\label{sub:agilismo}

Atividades como escrever um livro, pintar um quadro ou esculpir uma escultura são atividades quase essencialmente intelectuais. Estas atividades possui três características fundamentais \cite{XPTeles}:

\begin{itemize}
  \item \textbf{Necessidade de revisões}: Ao escrever um livro, o autor revisa e corrige o texto diversas vezes até que a obra adquira sua forma final, De maneira semelhante, um escultor faz diversos retoques até que sua escultura esteja finalizada.
  \item \textbf{Ausência de linearidade}: Dificilmente um autor começa o livro no primeiro capítulo e segue escrevendo até o último, um capítulo de cada vez, na mesma sequencia em que aparecem no índice. Igualmente, é improvável que um escultor ao esculpir uma obra siga um caminho linear.
  \item \textbf{Ausência de determinismo}: Não é possível dizer os passos exatos que o autor seguirá para produzir uma obra, muito menos a ordem em que estes passos serão dados. Cada autor segue um caminho distinto.
\end{itemize}

Segundo \citeonline{XPTeles}, estas características se originam no fato de o autor aprender enquanto produz e esse aprendizado vem do feedback que a obra fornece para seu criador, como se houvesse um diálogo permanente entre eles. Na medida em que ele a avalia, a obra mostra ao autor os pontos que precisam ser aprimorados ou necessitam de adições. Em síntese, o trabalho intelectual se caracteriza por aprendizado  permanente que leva a melhorias e torna o produto final mais adequado para o seu público.

O desenvolvimento de software é essencialmente uma atividade intelectual e criativa, exigindo a manipulação de uma gama muito grande de conhecimentos e informações. Além disso, além do autor de um software se preocupar com o conteúdo e estrutura, ele deve ser preocupar também com o comportamento, diferente da escrita de um livro ou da criação de uma escultura, fazendo com o que o desenvolvimento de software seja ainda mais complexo que estas atividades.

Sendo assim, o desenvolvimento de software tem uma semelhança muito maior com a prestação de serviços $-$ e até mesmo com atividades artísticas $-$ do que com manufaturas fordistas. Isto confirma que o desenvolvimento de software seja uma atividade que deve ser realizada por trabalhadores do conhecimento, não por trabalhadores manuais.

Em 2001 um grupo de dezessete especialistas, reconhecidos pela comunidade como grandes nomes do desenvolvimento software, se reuniram para discutir sobre um crescente conjunto de métodos que vinham surgindo e decidiram usar o termo Agilismo para descrever essa nova geração de métodos ágeis \cite{AgileStory}. Na mesma reunião, eles também escreveram o Manifesto Ágil \cite{AgileManifesto}, delineando um conjunto de valores e princípios que, em resumo, trilham um caminho para a eliminação de documentação e processos desnecessários, buscando a simplicidade, com foco na geração de valor e proximidade com o cliente, além de possibilitar respostas rápidas e eficazes às mudanças. O foco, antes fixado no processo, passa a ser nas pessoas e as mudanças, antes fortemente evitadas, são abraçadas.

Pode-se dizer então, que o Desenvolvendo Ágil, ou Agilismo, é um rótulo genérico para os métodos de desenvolvimento de software baseados no Manifesto Ágil \cite{BDDRodrigo}.

É importante citar que o desenvolvimento ágil sofreu grande influência de um conceito conhecido como \textit{Lean Thinking} (``pensamento enxuto"\ em português), uma linha de pensamento em gestão baseada nos princípios de \textit{Lean Manufactoring}\footnote{Os princípios de \textit{Lean Manufactoring} são originários do sistema Toyota de produção, que propôs um modo inteiramente novo de pensar a respeito de fabricação e logística de automóveis.} que se caracteriza por produção em pequenos lotes, eliminação de desperdícios, obsessão com qualidade, equipes multifuncionais praticando aprendizado contínuo, melhoria contínua de processo, sistema puxado de produção e a qualidade sendo responsabilidade dos trabalhadores como um todo \cite{BDDRodrigo}.

Uma das premissas do agilismo é que o custos de alterações é praticamente linear ao longo do tempo, independente do ponto em que esteja, fazendo com que a curva de custo de alterações seja semelhante à apresentada na Figura \ref{img:custo-agile}.

\begin{figure}[h]
  \center
  \caption{O custo das modificações no modelo ágil - Fonte: \cite{XPKent}}
  \includegraphics[scale=0.45]{images/custo-agile}
  \label{img:custo-agile}
\end{figure}

Isto é conseguido porque, diferentemente dos métodos tradicionais, os métodos ágeis não fazem um planejamento inicial muito abrangente. Ao invés disso, o desenvolvimento é dividido em iterações curtas (de uma a quatro semanas), onde ao início de cada uma delas é feito um novo planejamento, corrigindo o curso do projeto com base no \textit{feedback} obtido nas iterações anteriores. Para 10isso, a proximidade e interação do cliente com o projeto deve ser constante. Desta forma, o desenvolvimento é baseado em \textit{feedback} concreto e não em especulações sobre o futuro, o que é comum nos métodos tradicionais \cite{BDDRodrigo}.

\citeonline{MestradoTeles} cita um estudo em que os resultados mostram que 45\% das funcionalidades implementadas nunca são utilizadas, 19\% são raramente utilizadas, 16\% às vezes, 13\% frequentemente e apenas 7\% das funcionalidades são utilizadas sempre. Ou seja, 45\% do trabalho é totalmente inútil, enquanto apenas 20\% é a parte que gera mais retorno para o cliente. Isto é um outro efeito do grande planejamento inicial feito nos métodos tradicionais. Como o cliente tem apenas uma oportunidade para dizer o que ele precisa, sem nem mesmo saber direito o que é. Isso não ocorre nos métodos ágeis, pois a cada iteração o cliente aprende ao ver o que foi produzido nas iterações anteriores $-$ software realmente funcionado $-$ e pode dizer com muito mais certeza o que ainda é necessário ser desenvolvido.

Ao utilizar métodos ágeis, mais especificamente no \textit{eXtreme Programming} (XP), todas as funcionalidades dos sistema são levantadas através de histórias, que são escritas pelo próprio cliente em pequenos cartões. A equipe de desenvolvimento utiliza os cartões para saber quais funcionalidades são desejadas pelo cliente. Contudo, os cartões podem acabar representando histórias que consomem muito esforço para serem implementadas. Nesse caso, a equipe divide os cartões em tarefas, que são registradas em novos cartões para serem distribuídas facilmente entre os desenvolvedores.

No início do projeto o cliente e a equipe de desenvolvimento divide o projeto em \textit{releases}, que são entregas de software que implementem um conjunto de funcionalidades que possui um valor bem definido para o cliente. Essas estregas são feitas de forma incremental, e em um curto espaço de tempo (geralmente dois meses), para que o cliente possa começar a utilizar e obter os benefícios que elas oferecem, além de dar o \textit{feedback} necessário para que sejam feitas melhorias. Depois de definida a primeira \textit{release}, o cliente escreve as histórias que serão implementas nesta. As histórias das \textit{releases} posteriores podem ser deixadas para o futuro, pois durante o desenvolvimento de cada \textit{release} o cliente irá utilizar o software diversas vezes, o que irá influenciar as histórias das próximas \textit{release}. Durante a \textit{release} o cliente pode alterar as histórias se considerar necessário, podendo assim incorporar o aprendizado adquirido com o uso do sistema.

Uma \textit{release}, mesmo que seja pequena, representa um tempo ainda grande. Assim, ela é dividida em um conjunto de iterações, que são basicamente um pequeno espaço de tempo (geralmente duas semanas) dedicado para a implementação de um conjunto de histórias. A diferença entre uma \textit{release} e uma iteração é que na iteração o cliente não pode alterar as histórias definidas, pois a mudanças muito frequentes ao longo do trabalho da equipe de desenvolvimento prejudicam o ritmo de programação, pois confundem os desenvolvedores. No início de cara iteração é feita uma reunião para o planejamento da mesma, de modo que cliente e equipe de desenvolvimento definam as histórias que serão implementadas na iteração. Ao final de cada iteração e cada \textit{release}, o cliente ter novas histórias implementadas, ou seja, software funcionando. Dessa forma, ele poderá utilizar o sistema com as novas funcionalidades, tornando o \textit{feedback} é ainda mais efetivo.

Mas para que isso seja possível, os métodos ágeis contam com um conjunto de técnicas para dar suporte à seu caráter iterativo e incremental, sendo algumas destas técnicas serão abordadas mais adiante neste trabalho.

% subsection agilismo (end)

% section desenvolvimento_de_software (end)

\section{Tipos de teste}
\label{sec:tipos_de_teste}

TODO: Rodrigo: [Explique melhor (e com exemplos) cada tipo de teste, relacionando as definiçoes na literatura ágil com as definições na literatura tradicional.]

\subsection{Testes de unidade}
\label{sub:testes_de_unidade}

Testes de unidade são testes nos quais unidades individuais do sistema são testadas para determinar se estão aptas para uso. Uma unidade é a menor parte testável de uma aplicação. Em programação procedural uma unidade pode ser uma função ou \textit{procedure}. Já em programação orientada a objetos, uma unidade pode ser um método.

% subsection testes_de_unidade (end)

\subsection{Testes de integração}
\label{sub:testes_de_integracao}

Teste de integração testam as integrações do código com o mundo exterior. Podem ser um teste que se comunique através da rede, tenha contato com o sistema de arquivos ou deixe os limites de seu próprio processo \cite{ArtOfAgileDevelopment}.

% subsection testes_de_integracao (end)

\subsection{Testes de aceitação}
\label{sub:testes_de_aceitacao}

Testes de aceitação são especificações para o comportamento e funcionalidade de um sistema. Os testes de aceitação nos mostram se o sistema se comporta corretamente pela perspectiva de um usuário, sem nos dizer nada sobre como o sistema implementa esse comportamento \cite{TestDrivenKoskela}.

% subsection testes_de_aceitacao (end)

% section tipos_de_teste (end)